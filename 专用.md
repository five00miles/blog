数组乱序【洗牌算法】

大数相乘

大数相加

[1,2,3,4,6,7,9,13,15]=>['1->4',6->7,'9','13','15']

二叉树的坡度

二叉树的右视图

数组全排列，数组无重复项

数组全排列，数组有重复项

Promise限流，按照个数及时间限制并行数量，通过add新增

串行执行Promise，且上一个的结果为下一个的入参

react-virtualize

react fiber

## 手写防抖节流

## 实现Promise.all
```js
Promise.prototype.all = function(promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function(resolve, reject) {
    for (let val of promises) {
      Promise.resolve(val).then(function(res) {
        promiseCount++;
        // results.push(res);
        results[i] = res;
        // 当所有函数都正确执行了，resolve输出所有返回结果。
        if (promiseCount === promisesLength) {
          return resolve(results);
        }
      }, function(err) {
        return reject(err);
      });
    }
  });
};

// 第二种
/** 仅考虑 promises 传入的是数组的情况时 */
Promise.all = function (promise) {
	let promises = Array.from(promise)//将iterator转换为数组
    return new Promise((resolve, reject) => {
        if (promises.length === 0) {//如果数组长度为0则返回空数组
            resolve([]);
        } else {
            let result = [];//存放已成功的异步操作
            let index = 0;//记录已成功的操作数
            for (let i = 0;  i < promises.length; i++ ) {
                Promise.resolve(promises[i])//执行每一个promise
                	.then(data => {
                    	result[i] = data;
                    	if (++index === promises.length) {
                        //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态
                       	 resolve(result);
                    }
                }, err => {
                    reject(err);
                    return;
                });
            }
        }
    });
}
```

## Promise.race
```js
var race = function(promise) {
  let promises = Array.from(promise)
  return new Promise(function(resolve, reject) {
      for (var i = 0; i < promises.length; i++) {
          Promise.resolve(promises[i]).then(data => {
      resolve(data);
            }, err => {
              return reject(err)
      })
    }
  })
}
```

## Promise.resolve  和  Promise.reject
```js
// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))

p.then(null, function (s) {
  console.log(s)      // 出错了
});

Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))
```

## Promise.allsetled
```js
function PromiseAllSettled(promiseArr) {
	return new Promise((resolve, reject) => {
		if(!Array.isArray(promiseArr)) {
			reject(new TypeError("arguments must be an array"))
		}
		
		const promiseLen = promiseArr.length;
		const res = [];
		let count = 0;
		for(let i=0; i<promiseLen; i++) {
			Promise.resolve(promiseArr[i])
			.then((value) => {
				res[i] = {
					status: 'fulfilled',
					value
				}
			})
			.catch((reason) => {
				res[i] = {
					status: 'rejected',
					reason
				}
			})
			.finally(() => {
				count++;
				if(count == promiseLen) {
					resolve(res)
				}
			})
		}
	})
}


function allSettled(promises){
//只需要把rejected的情况捕获一下，并返回一个正常值，状态就会进入到fulFilled
      return Promise.all(promises.map(item=>Promise.resolve(item)
      .then(res=>({status:'fulfilled',value:res}),
             err=>({status:'rejected',reason:err}))
      ))
}



function allSettled(promises){
    return new Promise((resolve)=>{
        promises = Array.isArray(promises)?promises:[]
        let count = promises.length
        let result = []
        for(let i = 0;i < promises.length; i++){
            Promise.resolve(promises[i]).then(res=>result[i]={status:'fulfilled',value:res},
            err=>result[i] = {status:'rejected',reason:err})
            .finally(()=>{
                if(--count<=0){
                    resolve(result)
                }
            })
        }
    })
}
```

## Promise.retry
```js
/**
 * @description: 加入失败后使用失败重试功能，如果5次中有任意一次成功了，就停止尝试并返回
 * @param  {*}
 * @return {*}
 * @param {*} fn 绑定函数
 * @param {*} times 请求次数
 * @param {*} delay 延迟时间
 */
Promise.retry = function(fn,times,delay){
    let tryTimes = 0
    return new Promise((resolve,reject)=>{
        function attempt(){
            console.log(tryTimes)
            Promise.resolve(fn()).then(res=>{
                return resolve(res)
            }).catch(err=>{
                if(++tryTimes<times){
                    setTimeout(attempt,delay)
                }else{
                    return reject(err)
                }
            })
        }
        attempt()
    })
}
```

## 手写实现EventEmitter，包含emit，on，off，once
```js
class EventEmitter {
  constructor() {
    this._events = Object.create(null); // 定义事件的存储对象
    this._eventsCount = 0;
  }
  //添加事件监听
  on(eventName, fn, isOnce = false) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function!");
    }
    if (!this._events[eventName]) {
      this._events[eventName] = [];
      this._events[eventName].push({ fn, isOnce });
    } else {
      this._events[eventName].push({ fn, isOnce }); // 存入监听的事件名和事件
    }
  }

  //一次性事件监听
  once(eventName, fn) {
    this.on(eventName, fn, true);
  }

  // 事件触发
  emit(eventName, ...args) {
    if (!this._events[eventName]) {
      return false;
    }
    const len = this._events[eventName].length;
    for (let i = 0; i < len; i++) {
      let event = this._events[eventName][i];
      event.fn.call(this, ...args);
      if (event.isOnce) {
        this.removeListener(eventName, event.fn);
        i--;
      }
    }
  }
  // 移除监听事件
  removeListener(eventName, fn) {
    if (!this._events[eventName]) return this;
    if (!fn) {
      delete this._events[eventName];
      return this;
    } else {
      this._events[eventName].forEach((item, index) => {
        if (item.fn === fn) {
          this._events[eventName].splice(index, 1);
        } else {
          return this;
        }
      });
    }
  }
  // off:removeListener 的别名
  off(eventName, fn) {
    this.removeListener(eventName, fn);
  }
  // 移除所有监听事件
  removeAllListener(eventName) {
    if (eventName) {
      if (this._events[eventName]) {
        this._events[eventName].length = 0;
      }
    } else {
      this._events = Object.create(null);
    }
  }
}
```

## 手写一个深拷贝，解决循环引用的问题
```js
// 深拷贝 基本类型变量 symbol，方法 都可以拷贝
function isObject(val) {
  const valType = typeof val;
  return val && (valType === "object" || valType === "function");
}
function deepCopy(originValue) {
  // 创建一个map 主要是为了解决循环引用
  const loopRef = new WeakMap();
  function _deepCopy(originValue) {
    // symbol作为值的时候 我们需要重新创建一个symbol对象 
    if (typeof originValue === "symbol") {
      return Symbol(originValue.description);
    }
    // 基本类型，以及函数类型 直接返回 函数是为了复用 不需要重新创建一个
    if (!isObject(originValue) || typeof originValue === "function") return originValue;
    // 是set 和 map
    if (Object.prototype.toString.call(originValue).slice(8, -1) === "Set") {
      const newSet = new Set();
      originValue.forEach(value => {
        newSet.add(_deepCopy(value));
      });
      return newSet;
    }
    if (originValue instanceof Map) {
      const newMap = new Map();
      originValue.forEach((value, key) => {
        newMap.set(key, _deepCopy(value));
      });
      return newMap;
    }
    // 如果当前的对象已经在loopRef循环引用map里面存在了，不需要再次创建新对象 直接取出来返回即可了
    if (loopRef.has(originValue)) return loopRef.get(originValue);
    // 是对象 数组
    const newObject = Array.isArray(originValue) ? [] : {};
    // 把对象添加到我们的循环引用map中
    loopRef.set(originValue, newObject);
    for (const key in originValue) { // symbol作为key的时候 不会遍历到
      newObject[key] = _deepCopy(originValue[key]);
    }
    // 拿到作为key的symbol
    const symbolKeys = Object.getOwnPropertySymbols(originValue);
    for (const key of symbolKeys) {
      newObject[key] = _deepCopy(key);
    }
    return newObject;
  }
  return _deepCopy(originValue);
}
```

## 判断两个数组相等，可能是个二维数组，返回Boolean
```js
// Warn if overriding existing method
if(Array.prototype.equals)
    console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// attach the .equals method to Array's prototype to call it on any array
Array.prototype.equals = function (array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time
    if (this.length != array.length)
        return false;

    for (var i = 0, l = this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
                return false;
        }
        else if (this[i] != array[i]) {
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;
        }
    }
    return true;
}
// Hide method from for-in loops
Object.defineProperty(Array.prototype, "equals", {enumerable: false});
```

## 比较Object的方法
```js
Object.prototype.equals = function(object2) {
  //For the first loop, we only check for types
  for (propName in this) {
    //Check for inherited methods and properties - like .equals itself
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty
    //Return false if the return value is different
    if (this.hasOwnProperty(propName) != object2.hasOwnProperty(propName)) {
      return false;
    }
    //Check instance type
    else if (typeof this[propName] != typeof object2[propName]) {
      //Different types => not equal
      return false;
    }
  }
  //Now a deeper check using other objects property names
  for (propName in object2) {
    //We must check instances anyway, there may be a property that only exists in object2
    //I wonder, if remembering the checked values from the first loop would be faster or not 
    if (this.hasOwnProperty(propName) != object2.hasOwnProperty(propName)) {
      return false;
    }
    else if (typeof this[propName] != typeof object2[propName]) {
      return false;
    }
    //If the property is inherited, do not check any more (it must be equa if both objects inherit it)
    if (!this.hasOwnProperty(propName))
      continue;

    //Now the detail check and recursion

    //This returns the script back to the array comparing
    /**REQUIRES Array.equals**/
    if (this[propName] instanceof Array && object2[propName] instanceof Array) {
      // recurse into the nested arrays
      if (!this[propName].equals(object2[propName]))
        return false;
    }
    else if (this[propName] instanceof Object && object2[propName] instanceof Object) {
      // recurse into another objects
      //console.log("Recursing to compare ", this[propName],"with",object2[propName], " both named \""+propName+"\"");
      if (!this[propName].equals(object2[propName]))
        return false;
    }
    //Normal value comparison for strings and numbers
    else if (this[propName] != object2[propName]) {
      return false;
    }
  }
  //If everything passed, let's say YES
  return true;
}
```

## 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
```js
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
  s = [...s]
  // if (s[0] == 0) return []
  let list = [], lists = []

  run(s, 4)
  function checkNum(number) {
      return ((number <= 255 && (parseInt(number)+'').length == number.length))
  }
  function run(s, level) {
      if (level == 1) {
          const target = s.join('')
          if (checkNum(target)) {
              list.push(target)
              lists.push([].concat(list).join('.'))
              list.pop()
          }
          return
      }

      const lvl = level - 1
      let number = 1
      while (s.length >= number && number <= 3) {
          const target = [].concat(s).splice(0, number).join('')
          if (checkNum(target)) {
              list.push(target)
              run([].concat(s).slice(number), lvl)
              list.pop()
          }
          number++
      }
  }

  return lists
};
```
